// Generated by CoffeeScript 1.7.1
(function() {
  var CompoundError, Observer, Signal, assert, _ref;

  assert = require('assert');

  _ref = require('./reactor'), Signal = _ref.Signal, Observer = _ref.Observer, CompoundError = _ref.CompoundError;

  describe('Signal', function() {
    describe('Initialization', function() {
      return it('should initialize without error', function() {
        var arraySignal, numberSignal, objectSignal, stringSignal;
        numberSignal = Signal(123456789);
        stringSignal = Signal("foo");
        arraySignal = Signal([]);
        return objectSignal = Signal({});
      });
    });
    describe('Reading', function() {
      it('should read the inital value without error', function() {
        var arraySignal, numberSignal, objectSignal, stringSignal;
        numberSignal = Signal(123456789);
        stringSignal = Signal("foo");
        arraySignal = Signal([]);
        objectSignal = Signal({});
        numberSignal();
        stringSignal();
        arraySignal();
        return objectSignal();
      });
      it('should return the initial value when read', function() {
        var arraySignal, arrayValue, numberSignal, numberValue, objectSignal, objectValue, stringSignal, stringValue;
        numberValue = 123456789;
        stringValue = "foo";
        arrayValue = [];
        objectValue = {};
        numberSignal = Signal(numberValue);
        stringSignal = Signal(stringValue);
        arraySignal = Signal(arrayValue);
        objectSignal = Signal(objectValue);
        assert.equal(numberSignal(), 123456789);
        assert.equal(stringSignal(), "foo");
        assert.equal(arraySignal(), arrayValue);
        return assert.equal(objectSignal(), objectValue);
      });
      return it('should be readable multiple times without changing the value', function() {
        var a, aValue;
        aValue = 123456789;
        a = Signal(123456789);
        assert.equal(a(), 123456789);
        assert.equal(a(), 123456789);
        assert.equal(a(), 123456789);
        assert.equal(a(), 123456789);
        return assert.equal(a(), 123456789);
      });
    });
    describe('Writing', function() {
      it('should write a new value without error', function() {
        var arraySignal, numberSignal, objectSignal, stringSignal;
        numberSignal = Signal(123456789);
        stringSignal = Signal("foo");
        arraySignal = Signal([]);
        objectSignal = Signal({});
        numberSignal(987654321);
        stringSignal("bar");
        arraySignal([]);
        return objectSignal({});
      });
      it('should return the written value on write', function() {
        var arraySignal, newArrayValue, newNumberValue, newObjectValue, newStringValue, numberSignal, objectSignal, stringSignal;
        numberSignal = Signal(123456789);
        stringSignal = Signal("foo");
        arraySignal = Signal(["a", "b", "c"]);
        objectSignal = Signal({
          "foo": 1
        });
        newNumberValue = 987654321;
        newStringValue = "bar";
        newArrayValue = [1, 2, 3];
        newObjectValue = {
          "bar": 2
        };
        assert.equal(numberSignal(newNumberValue), newNumberValue);
        assert.equal(stringSignal(newStringValue), newStringValue);
        assert.equal(arraySignal(newArrayValue), newArrayValue);
        return assert.equal(objectSignal(newObjectValue), newObjectValue);
      });
      return it('should return the new value on subsequent reads', function() {
        var arraySignal, newArrayValue, newNumberValue, newObjectValue, newStringValue, numberSignal, objectSignal, stringSignal;
        numberSignal = Signal(123456789);
        stringSignal = Signal("foo");
        arraySignal = Signal(["a", "b", "c"]);
        objectSignal = Signal({
          "foo": 1
        });
        newNumberValue = 987654321;
        newStringValue = "bar";
        newArrayValue = [1, 2, 3];
        newObjectValue = {
          "bar": 2
        };
        numberSignal(newNumberValue);
        stringSignal(newStringValue);
        arraySignal(newArrayValue);
        objectSignal(newObjectValue);
        assert.equal(numberSignal(), newNumberValue);
        assert.equal(stringSignal(), newStringValue);
        assert.equal(arraySignal(), newArrayValue);
        return assert.equal(objectSignal(), newObjectValue);
      });
    });
    describe('Propagation', function() {
      it("should initialize a dependent signal without error", function() {
        var a, b;
        a = Signal(1);
        return b = Signal(function() {
          return a() + 1;
        });
      });
      it("should initialize a dependent signal with the correct value", function() {
        var a, b;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        return assert.equal(b(), 2);
      });
      it('should propagate changes to a dependent signal', function() {
        var a, b;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        a(2);
        return assert.equal(b(), 3);
      });
      it('should initialize multiple dependent signals without error', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        return c = Signal(function() {
          return a() + 2;
        });
      });
      it('should initialize multiple dependent signals with the correct values', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          return a() + 2;
        });
        assert.equal(a(), 1);
        assert.equal(b(), 2);
        return assert.equal(c(), 3);
      });
      it('should propagate changes to multiple dependent signals', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          return a() + 2;
        });
        a(2);
        assert.equal(a(), 2);
        assert.equal(b(), 3);
        return assert.equal(c(), 4);
      });
      it('should initialize sequential dependencies without error', function() {
        var a, b, c, d;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          return b() + 1;
        });
        return d = Signal(function() {
          return c() + 1;
        });
      });
      it('should initialize sequential dependencies with the correct values', function() {
        var a, b, c, d;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          return b() + 1;
        });
        d = Signal(function() {
          return c() + 1;
        });
        assert.equal(a(), 1);
        assert.equal(b(), 2);
        assert.equal(c(), 3);
        return assert.equal(d(), 4);
      });
      it('should propagate changes to sequential dependencies', function() {
        var a, b, c, d;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          return b() + 1;
        });
        d = Signal(function() {
          return c() + 1;
        });
        a(10);
        assert.equal(a(), 10);
        assert.equal(b(), 11);
        assert.equal(c(), 12);
        return assert.equal(d(), 13);
      });
      it('should initialize convergent dependencies without error', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(2);
        return c = Signal(function() {
          return a() + b();
        });
      });
      it('should initialize convergent dependencies with the correct value', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(2);
        c = Signal(function() {
          return a() + b();
        });
        assert.equal(a(), 1);
        assert.equal(b(), 2);
        return assert.equal(c(), 3);
      });
      it('should propagate changes to convergent dependencies', function() {
        var a, b, c;
        a = Signal(1);
        b = Signal(2);
        c = Signal(function() {
          return a() + b();
        });
        a(7);
        assert.equal(a(), 7);
        assert.equal(b(), 2);
        assert.equal(c(), 9);
        b(3);
        assert.equal(a(), 7);
        assert.equal(b(), 3);
        return assert.equal(c(), 10);
      });
      it("should break unneeded dependencies after manual redefinition", function() {
        var a, b;
        a = Signal(1);
        b = Signal(function() {
          return a();
        });
        assert.equal(a(), 1);
        assert.equal(b(), 1);
        a(2);
        assert.equal(a(), 2);
        assert.equal(b(), 2);
        b(3);
        assert.equal(a(), 2);
        assert.equal(b(), 3);
        a(7);
        assert.equal(a(), 7);
        return assert.equal(b(), 3);
      });
      it("should dynamically determine dependencies", function() {
        var a, b, c, d, triggerCount;
        triggerCount = 0;
        a = Signal(true);
        b = Signal("foo");
        c = Signal("bar");
        d = Signal(function() {
          triggerCount += 1;
          if (a()) {
            return b();
          } else {
            return c();
          }
        });
        assert.equal(triggerCount, 1);
        b("hi");
        assert.equal(triggerCount, 2);
        c("hello");
        assert.equal(triggerCount, 2);
        a(false);
        assert.equal(triggerCount, 3);
        c("hello again");
        assert.equal(triggerCount, 4);
        b("hi again");
        return assert.equal(triggerCount, 4);
      });
      return it("should only propagate changes to signals which have not seen the value already", function() {
        var a, b, c, triggerCount;
        triggerCount = 0;
        a = Signal(1);
        b = Signal(function() {
          return a() + 1;
        });
        c = Signal(function() {
          a() + b();
          return triggerCount += 1;
        });
        a(2);
        return assert.equal(triggerCount, 2);
      });
    });
    return describe("Array and Object convenience methods", function() {
      it("should be able to call object set without error", function() {
        var aSignal;
        aSignal = Signal({});
        return aSignal.set("foo", 1);
      });
      it("should have its value using object set", function() {
        var aSignal;
        aSignal = Signal({});
        aSignal.set("foo", 1);
        assert.equal(JSON.stringify(aSignal()), '{"foo":1}');
        aSignal.set("bar", 2);
        return assert.equal(JSON.stringify(aSignal()), '{"foo":1,"bar":2}');
      });
      it("should not have set on non object signals`", function() {
        var aSignal;
        aSignal = Signal(1);
        return assert.equal(aSignal.set, void 0);
      });
      it("should remove set once signal is no longer object", function() {
        var aSignal;
        aSignal = Signal({});
        aSignal(1);
        return assert.equal(aSignal.set, void 0);
      });
      it("should propagate the value when using the object set convenience method", function() {
        var aSignal, bSignal;
        aSignal = Signal({});
        bSignal = Signal(function() {
          return "Serialized: " + JSON.stringify(aSignal());
        });
        assert.equal(JSON.stringify(aSignal()), "{}");
        aSignal.set("foo", 1);
        return assert.equal(bSignal(), 'Serialized: {"foo":1}');
      });
      it("should call array mutator convenience methods without error", function() {
        var arraySignal;
        arraySignal = Signal([]);
        arraySignal.push("x");
        arraySignal.pop();
        arraySignal.unshift("x");
        arraySignal.shift();
        arraySignal.sort(function(x, y) {
          return x(-y);
        });
        arraySignal.reverse();
        return arraySignal.splice(0, 0, "x");
      });
      it("should modify the array correctly when using array convenience methods", function() {
        var arraySignal, controlArray, controlOutput, signalOutput;
        controlArray = [];
        arraySignal = Signal([]);
        controlOutput = controlArray.push("x");
        signalOutput = arraySignal.push("x");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.push("y");
        signalOutput = arraySignal.push("y");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.push("z");
        signalOutput = arraySignal.push("z");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.pop();
        signalOutput = arraySignal.pop();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.pop();
        signalOutput = arraySignal.pop();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.pop();
        signalOutput = arraySignal.pop();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.unshift("a");
        signalOutput = arraySignal.unshift("a");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.unshift("b");
        signalOutput = arraySignal.unshift("b");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.unshift("c");
        signalOutput = arraySignal.unshift("c");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.shift();
        signalOutput = arraySignal.shift();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.shift();
        signalOutput = arraySignal.shift();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.shift();
        signalOutput = arraySignal.shift();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.push(4, 2, 3, 1, 5);
        signalOutput = arraySignal.push(4, 2, 3, 1, 5);
        controlOutput = controlArray.sort(function(x, y) {
          return x - y;
        });
        signalOutput = arraySignal.sort(function(x, y) {
          return x - y;
        });
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.reverse();
        signalOutput = arraySignal.reverse();
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
        controlOutput = controlArray.splice(1, 1, "hello there");
        signalOutput = arraySignal.splice(1, 1, "hello there");
        assert.equal(JSON.stringify(arraySignal()), JSON.stringify(controlArray));
        return assert.equal(JSON.stringify(controlOutput), JSON.stringify(signalOutput));
      });
      return it("should propagate changes when using array convenience methods", function() {
        var arraySignal, dependentSignal;
        arraySignal = Signal([]);
        dependentSignal = Signal(function() {
          return JSON.stringify(arraySignal);
        });
        arraySignal.push("x");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.push("y");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.push("z");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.pop();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.pop();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.pop();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.unshift("a");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.unshift("b");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.unshift("c");
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.shift();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.shift();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.shift();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.push(4, 2, 3, 1, 5);
        arraySignal.sort(function(x, y) {
          return x - y;
        });
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.reverse();
        assert.equal(dependentSignal(), JSON.stringify(arraySignal));
        arraySignal.splice(1, 1, "hello there");
        return assert.equal(dependentSignal(), JSON.stringify(arraySignal));
      });
    });
  });

  describe("Observer", function() {
    it("should initialize a blank observer without error", function() {
      var anObserver;
      return anObserver = Observer(function() {});
    });
    it("should initialize an observer which reads a signal without error", function() {
      var aSignal, anObserver;
      aSignal = Signal(1);
      return anObserver = Observer(function() {
        return aSignal();
      });
    });
    it("should trigger an observer on evaluation", function() {
      var aSignal, anExternalValue, anObserver;
      aSignal = Signal(1);
      anExternalValue = null;
      assert.equal(anExternalValue, null);
      anObserver = Observer(function() {
        return anExternalValue = aSignal();
      });
      return assert.equal(anExternalValue, 1);
    });
    it("should trigger the observer when a signal is updated", function() {
      var aSignal, anExternalValue, anObserver;
      aSignal = Signal(1);
      anExternalValue = null;
      anObserver = Observer(function() {
        return anExternalValue = aSignal();
      });
      aSignal(2);
      return assert.equal(anExternalValue, 2);
    });
    it("should trigger the observer when a signal is updated multiple times", function() {
      var aSignal, anExternalValue, anObserver;
      aSignal = Signal(1);
      anExternalValue = null;
      anObserver = Observer(function() {
        return anExternalValue = aSignal();
      });
      aSignal(2);
      assert.equal(anExternalValue, 2);
      aSignal(3);
      assert.equal(anExternalValue, 3);
      aSignal(4);
      assert.equal(anExternalValue, 4);
      aSignal(5);
      return assert.equal(anExternalValue, 5);
    });
    it("should trigger even when observing multiple signals", function() {
      var aSignal, anExternalValue, anObserver, bSignal, cSignal, dSignal;
      aSignal = Signal(1);
      bSignal = Signal(2);
      cSignal = Signal(3);
      dSignal = Signal(4);
      anExternalValue = 0;
      anObserver = Observer(function() {
        return anExternalValue = "" + aSignal() + bSignal() + cSignal() + dSignal();
      });
      assert.equal(anExternalValue, "1234");
      aSignal(5);
      assert.equal(anExternalValue, "5234");
      bSignal(6);
      assert.equal(anExternalValue, "5634");
      cSignal(7);
      assert.equal(anExternalValue, "5674");
      dSignal(8);
      return assert.equal(anExternalValue, "5678");
    });
    return it("should write to another signal without building a dependency", function() {
      var aSignal, anObserver, bSignal, triggerCount;
      triggerCount = 0;
      aSignal = Signal(1);
      bSignal = Signal(2);
      anObserver = Observer(function() {
        triggerCount += 1;
        return bSignal(aSignal());
      });
      assert.equal(triggerCount, 1);
      assert.equal(bSignal(), 1);
      aSignal(3);
      assert.equal(triggerCount, 2);
      assert.equal(bSignal(), 3);
      bSignal(4);
      assert.equal(triggerCount, 2);
      return assert.equal(bSignal(), 4);
    });
  });

  describe('Error Handling', function() {
    it("should throw error immediately on invalid signal definition", function() {
      var error, errorfulDependentSignal, sourceSignal;
      sourceSignal = Signal(1);
      try {
        errorfulDependentSignal = Signal(function() {
          return sourceSignal() + nonExistentVariable;
        });
      } catch (_error) {
        error = _error;
        if (!(error instanceof ReferenceError)) {
          throw error;
        }
        return;
      }
      throw new Error("no error when errors expected");
    });
    it("should throw a CompoundError if multiple signals are affected", function() {
      var error, firstErrorfulDependentSignal, secondErrorfulDependentSignal, sourceSignal, thirdErrorfulDependentSignal;
      sourceSignal = Signal(1);
      firstErrorfulDependentSignal = Signal(function() {
        if (sourceSignal() > 2) {
          throw new RangeError("source too big!");
        } else {
          return sourceSignal();
        }
      });
      secondErrorfulDependentSignal = Signal(function() {
        return firstErrorfulDependentSignal();
      });
      thirdErrorfulDependentSignal = Signal(function() {
        return secondErrorfulDependentSignal();
      });
      try {
        sourceSignal(5);
      } catch (_error) {
        error = _error;
        if (!(error instanceof CompoundError)) {
          throw error;
        }
        return;
      }
      throw new Error("no error when errors expected");
    });
    return it("should throw an error even if only observers are affected", function() {
      var error, errorfulObserver, sourceSignal;
      sourceSignal = Signal(1);
      errorfulObserver = Observer(function() {
        if (sourceSignal() > 2) {
          throw new RangeError("source too big!");
        } else {
          return sourceSignal();
        }
      });
      try {
        sourceSignal(5);
      } catch (_error) {
        error = _error;
        return;
      }
      throw new Error("no error when error expected");
    });
  });

}).call(this);
