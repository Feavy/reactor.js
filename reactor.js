// Generated by CoffeeScript 1.7.1
(function() {
  var ARRAY_METHODS, OBSERVER, SIGNAL, dependencyStack, global,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  SIGNAL = "SIGNAL";

  OBSERVER = "OBSERVER";

  ARRAY_METHODS = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"];

  global = typeof exports !== "undefined" && exports !== null ? exports : this;

  dependencyStack = [];

  global.Signal = function(definition) {
    var signalCore, signalInterface;
    signalCore = {
      definition: null,
      value: null,
      dependencies: [],
      dependencyType: SIGNAL,
      dependents: [],
      observers: [],
      readers: [],
      error: null,
      evaluate: function() {
        var dependency, dependentIndex, error, property, _i, _len, _ref;
        _ref = this.dependencies;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dependency = _ref[_i];
          dependentIndex = dependency.dependents.indexOf(this);
          dependency.dependents[dependentIndex] = null;
        }
        this.dependencies = [];
        this.error = null;
        if (this.definition instanceof Function) {
          dependencyStack.push(this);
          try {
            this.value = this.definition();
          } catch (_error) {
            error = _error;
            this.error = error;
            for (property in this.error) {
              console.log(this.error[property]);
            }
          } finally {
            dependencyStack.pop();
          }
        } else {
          this.value = this.definition;
        }
        return this.readers = [];
      },
      propagate: function(observerList) {
        var dependency, observer, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this.observers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          observer = _ref[_i];
          if (observer != null) {
            if (__indexOf.call(observerList, observer) < 0) {
              observerList.push(observer);
            }
          }
        }
        _ref1 = this.dependents.slice(0);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dependency = _ref1[_j];
          if (!((dependency != null) && __indexOf.call(this.readers, dependency) < 0)) {
            continue;
          }
          dependency.evaluate();
          dependency.propagate(observerList);
        }
        return observerList;
      },
      read: function() {
        var dependent, signalError;
        dependent = dependencyStack[dependencyStack.length - 1];
        if ((dependent != null) && __indexOf.call(this.readers, dependent) < 0) {
          this.readers.push(dependent);
        }
        if ((dependent != null) && dependent.dependencyType === SIGNAL) {
          if (__indexOf.call(this.dependents, dependent) < 0) {
            this.dependents.push(dependent);
          }
          if (__indexOf.call(dependent.dependencies, this) < 0) {
            dependent.dependencies.push(this);
          }
        } else if ((dependent != null) && dependent.dependencyType === OBSERVER) {
          if (__indexOf.call(this.observers, dependent) < 0) {
            this.observers.push(dependent);
          }
          if (__indexOf.call(dependent.observees, this) < 0) {
            dependent.observees.push(this);
          }
        }
        if (this.error) {
          signalError = new Error("Signal corrupted with " + this.error);
          throw signalError;
        } else {
          return this.value;
        }
      },
      write: function(newDefinition) {
        var methodName, observer, observerList, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
        this.definition = newDefinition;
        if (this.definition instanceof Array) {
          _fn = (function(_this) {
            return function(methodName) {
              return signalInterface[methodName] = function() {
                var output;
                output = _this.definition[methodName].apply(_this.definition, arguments);
                _this.write(_this.definition);
                return output;
              };
            };
          })(this);
          for (_i = 0, _len = ARRAY_METHODS.length; _i < _len; _i++) {
            methodName = ARRAY_METHODS[_i];
            _fn(methodName);
          }
        } else {
          for (_j = 0, _len1 = ARRAY_METHODS.length; _j < _len1; _j++) {
            methodName = ARRAY_METHODS[_j];
            delete signalInterface[methodName];
          }
        }
        if (this.definition instanceof Object) {
          signalInterface.set = (function(_this) {
            return function(key, value) {
              _this.definition[key] = value;
              return _this.write(_this.definition);
            };
          })(this);
        } else {
          delete signalInterface.set;
        }
        this.evaluate();
        observerList = this.propagate([]);
        _ref = observerList.slice(0);
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          observer = _ref[_k];
          observer.trigger();
        }
        return this.value;
      }
    };
    signalInterface = function(newDefinition) {
      if (arguments.length === 0) {
        return signalCore.read();
      } else {
        return signalCore.write(newDefinition);
      }
    };
    signalCore.write(definition);
    return signalInterface;
  };

  global.Observer = function(response) {
    var observerCore, observerInterface;
    observerCore = {
      response: null,
      dependencyType: OBSERVER,
      observees: [],
      trigger: function() {
        var error, observee, observerIndex, _i, _len, _ref;
        _ref = this.observees;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          observee = _ref[_i];
          observerIndex = observee.observers.indexOf(this);
          observee.observers[observerIndex] = null;
        }
        this.observees = [];
        if (response instanceof Function) {
          dependencyStack.push(this);
          try {
            return this.response();
          } catch (_error) {
            error = _error;
          } finally {
            dependencyStack.pop();
          }
        }
      },
      write: function(newResponse) {
        this.response = newResponse;
        return this.trigger();
      }
    };
    observerInterface = function(newResponse) {
      return write(newResponse);
    };
    observerCore.write(response);
    return observerInterface;
  };

}).call(this);
