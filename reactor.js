// Generated by CoffeeScript 1.7.1
var ARRAY_METHODS, OBSERVER, SIGNAL, dependencyStack, global;

SIGNAL = "SIGNAL";

OBSERVER = "OBSERVER";

ARRAY_METHODS = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"];

global = typeof exports !== "undefined" && exports !== null ? exports : this;

dependencyStack = [];

global.Signal = function(definition) {
  var createdSignal, evaluate, signalCore, signalInterface, value;
  signalCore = {
    definition: null,
    value: null,
    dependencies: [],
    dependencyType: SIGNAL,
    dependents: [],
    observers: [],
    evaluate: function() {
      var dependency, dependentIndex, _i, _len, _ref;
      _ref = this.dependencies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dependency = _ref[_i];
        dependentIndex = dependency.dependents.indexOf(this);
        dependency.dependents[dependentIndex] = null;
      }
      this.dependencies = [];
      if (this.definition instanceof Function) {
        dependencyStack.push(this);
        this.value = this.definition();
        return dependencyStack.pop();
      } else {
        return this.value = this.definition;
      }
    },
    propagate: function(observerList) {
      var dependency, _i, _len, _ref;
      observerList.push.apply(observerList, this.observers);
      _ref = this.dependents;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dependency = _ref[_i];
        if (!(dependency != null)) {
          continue;
        }
        dependency.evaluate();
        dependency.propagate(observerList);
      }
      return observerList;
    },
    read: function() {
      var dependent;
      dependent = dependencyStack[dependencyStack.length - 1];
      if ((dependent != null) && dependent.dependencyType === SIGNAL) {
        if (this.dependents.indexOf(dependent) < 0) {
          this.dependents.push(dependent);
        }
        if (dependent.dependencies.indexOf(this) < 0) {
          dependent.dependencies.push(this);
        }
      } else if ((dependent != null) && dependent.dependencyType === OBSERVER) {
        if (this.observers.indexOf(dependent) < 0) {
          this.observers.push(dependent);
        }
        if (dependent.observees.indexOf(this) < 0) {
          dependent.observees.push(this);
        }
      }
      return this.value;
    },
    write: function(newDefinition) {
      var observerList, observerTrigger, _i, _len;
      this.definition = newDefinition;
      this.evaluate();
      observerList = this.propagate([]);
      for (_i = 0, _len = observerList.length; _i < _len; _i++) {
        observerTrigger = observerList[_i];
        observerTrigger();
      }
      return this.value;
    }
  };
  signalInterface = function(newDefinition) {
    if (newDefinition === void 0) {
      return signalCore.read();
    } else {
      return signalCore.write(newDefinition);
    }
  };
  signalCore.write(definition);
  return signalInterface;
  value = null;
  evaluate = function(observerList) {
    var arrayMethods, dependency, dependentEvaluate, dependentIndex, methodName, observerTrigger, _fn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _results;
    value = definition;
    _ref = evaluate.dependencies;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dependency = _ref[_i];
      dependentIndex = dependency.dependents.indexOf(evaluate);
      dependency.dependents[dependentIndex] = null;
    }
    evaluate.dependencies = [];
    arrayMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"];
    if (definition instanceof Array) {
      _fn = function(methodName) {
        return createdSignal[methodName] = function() {
          var output;
          output = definition[methodName].apply(definition, arguments);
          createdSignal(definition);
          return output;
        };
      };
      for (_j = 0, _len1 = arrayMethods.length; _j < _len1; _j++) {
        methodName = arrayMethods[_j];
        _fn(methodName);
      }
    } else {
      for (_k = 0, _len2 = arrayMethods.length; _k < _len2; _k++) {
        methodName = arrayMethods[_k];
        delete createdSignal[methodName];
      }
    }
    if (definition instanceof Object) {
      createdSignal.set = function(key, value) {
        definition[key] = value;
        return createdSignal(definition);
      };
    } else {
      delete createdSignal.set;
    }
    if (typeof definition === "function") {
      dependencyStack.push(evaluate);
      value = definition();
      dependencyStack.pop();
    }
    _ref1 = evaluate.observers.slice(0);
    for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
      observerTrigger = _ref1[_l];
      if ((observerTrigger != null) && observerList.indexOf(observerTrigger) < 0) {
        observerList.push(observerTrigger);
      }
    }
    evaluate.dependentTargets = evaluate.dependents.slice(0);
    _ref2 = evaluate.dependents.slice(0);
    _results = [];
    for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
      dependentEvaluate = _ref2[_m];
      if ((dependentEvaluate != null) && evaluate.dependentTargets.indexOf(dependentEvaluate) >= 0) {
        _results.push(dependentEvaluate(observerList));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  evaluate.dependencies = [];
  evaluate.dependencyType = SIGNAL;
  evaluate.dependents = [];
  evaluate.observers = [];
  evaluate.dependentTargets = [];
  createdSignal = function(newDefinition) {
    var dependent, observerList, observerTrigger, targetDependentIndex, _i, _len;
    if (newDefinition === void 0) {
      dependent = dependencyStack[dependencyStack.length - 1];
      if ((dependent != null) && dependent.dependencyType === SIGNAL) {
        if (evaluate.dependents.indexOf(dependent) < 0) {
          evaluate.dependents.push(dependent);
        }
        if (dependent.dependencies.indexOf(evaluate) < 0) {
          dependent.dependencies.push(evaluate);
        }
        targetDependentIndex = evaluate.dependentTargets.indexOf(dependent);
        if (targetDependentIndex >= 0) {
          evaluate.dependentTargets[targetDependentIndex] = null;
        }
      } else if ((dependent != null) && dependent.dependencyType === OBSERVER) {
        if (evaluate.observers.indexOf(dependent) < 0) {
          evaluate.observers.push(dependent);
        }
        if (dependent.observees.indexOf(evaluate) < 0) {
          dependent.observees.push(evaluate);
        }
      }
      return value;
    } else {
      definition = newDefinition;
      observerList = [];
      evaluate(observerList);
      for (_i = 0, _len = observerList.length; _i < _len; _i++) {
        observerTrigger = observerList[_i];
        observerTrigger();
      }
      return value;
    }
  };
  evaluate();
  return createdSignal;
};

global.Observer = function(response) {
  var createdObserver, trigger;
  trigger = function() {
    var observee, observerIndex, _i, _len, _ref;
    _ref = trigger.observees;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      observee = _ref[_i];
      observerIndex = observee.observers.indexOf(trigger);
      observee.observers[observerIndex] = null;
    }
    trigger.observees = [];
    dependencyStack.push(trigger);
    if (response !== null) {
      response();
    }
    return dependencyStack.pop();
  };
  trigger.observees = [];
  trigger.dependencyType = OBSERVER;
  createdObserver = function(newResponse) {
    response = newResponse;
    trigger();
    return null;
  };
  trigger();
  return createdObserver;
};
