// Generated by CoffeeScript 1.7.1
(function() {
  var CompoundError, OBSERVER, PseudoSet, SIGNAL, dependencyStack, global,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SIGNAL = "SIGNAL";

  OBSERVER = "OBSERVER";

  global = typeof exports !== "undefined" && exports !== null ? exports : this;

  dependencyStack = [];

  global.Signal = function(definition) {
    var signalCore, signalInterface;
    signalCore = {
      dependencyType: SIGNAL,
      definition: null,
      value: null,
      error: null,
      dependents: new PseudoSet(),
      dependencies: new PseudoSet(),
      update: function() {
        var error;
        this.dependencies.forEach((function(_this) {
          return function(dependency) {
            return dependency.dependents["delete"](_this);
          };
        })(this));
        this.dependencies.clear();
        this.error = null;
        if (this.definition instanceof Function) {
          dependencyStack.push(this);
          try {
            return this.value = this.definition();
          } catch (_error) {
            error = _error;
            this.error = error;
            throw error;
          } finally {
            dependencyStack.pop();
          }
        } else {
          return this.value = this.definition;
        }
      },
      read: function() {
        var dependent, signalError;
        dependent = dependencyStack[dependencyStack.length - 1];
        if (dependent != null) {
          this.dependents.add(dependent);
          dependent.dependencies.add(this);
        }
        if (this.error) {
          signalError = new Error('Reading from corrupted Signal');
          throw signalError;
        } else {
          return this.value;
        }
      },
      write: function(newDefinition) {
        var dependencyQueue, error, errorList, errorMessage, observer, observerList, target, _i, _len;
        this.definition = newDefinition;
        dependencyQueue = [this];
        observerList = [];
        errorList = [];
        while (dependencyQueue.length >= 1) {
          target = dependencyQueue.shift();
          try {
            target.update();
          } catch (_error) {
            error = _error;
            errorList.push(error);
          }
          target.dependents.forEach(function(dependent) {
            if (dependent.dependencyType === SIGNAL) {
              if (__indexOf.call(dependencyQueue, dependent) < 0) {
                return dependencyQueue.push(dependent);
              }
            } else if (dependent.dependencyType === OBSERVER) {
              if (__indexOf.call(observerList, dependent) < 0) {
                return observerList.push(dependent);
              }
            }
          });
        }
        for (_i = 0, _len = observerList.length; _i < _len; _i++) {
          observer = observerList[_i];
          try {
            observer.update();
          } catch (_error) {
            error = _error;
            errorList.push(error);
          }
        }
        if (errorList.length === 1) {
          throw errorList[0];
        } else if (errorList.length > 1) {
          errorMessage = errorList.length + " errors due to signal write";
          throw new CompoundError(errorMessage, errorList);
        }
        return this.value;
      }
    };
    signalInterface = function(newDefinition) {
      if (arguments.length === 0) {
        return signalCore.read();
      } else {
        if (newDefinition instanceof Object) {
          signalInterface.set = function(key, value) {
            var output;
            output = newDefinition[key] = value;
            signalCore.write(newDefinition);
            return output;
          };
        } else {
          delete signalInterface.set;
        }
        if (newDefinition instanceof Array) {
          signalInterface.push = function() {
            var output;
            output = newDefinition.push.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.pop = function() {
            var output;
            output = newDefinition.pop.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.shift = function() {
            var output;
            output = newDefinition.shift.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.unshift = function() {
            var output;
            output = newDefinition.unshift.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.reverse = function() {
            var output;
            output = newDefinition.reverse.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.sort = function() {
            var output;
            output = newDefinition.sort.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
          signalInterface.splice = function() {
            var output;
            output = newDefinition.splice.apply(newDefinition, arguments);
            signalCore.write(newDefinition);
            return output;
          };
        } else {
          delete signalInterface.push;
          delete signalInterface.pop;
          delete signalInterface.shift;
          delete signalInterface.unshift;
          delete signalInterface.reverse;
          delete signalInterface.sort;
          delete signalInterface.splice;
        }
        return signalCore.write(newDefinition);
      }
    };
    signalInterface(definition);
    return signalInterface;
  };

  global.Observer = function(definition) {
    var observerCore, observerInterface;
    observerCore = {
      dependencyType: OBSERVER,
      definition: null,
      dependencies: new PseudoSet(),
      update: function() {
        this.dependencies.forEach((function(_this) {
          return function(dependency) {
            return dependency.dependents["delete"](_this);
          };
        })(this));
        this.dependencies.clear();
        if (definition instanceof Function) {
          dependencyStack.push(this);
          try {
            return this.definition();
          } finally {
            dependencyStack.pop();
          }
        }
      },
      write: function(newdefinition) {
        this.definition = newdefinition;
        return this.update();
      }
    };
    observerInterface = function(newdefinition) {
      return write(newdefinition);
    };
    observerCore.write(definition);
    return observerInterface;
  };

  CompoundError = (function(_super) {
    __extends(CompoundError, _super);

    global.CompoundError = CompoundError;

    function CompoundError(message, errorArray) {
      var error, errorDescription, errorProperties, property, proxyError, _i, _j, _len, _len1, _ref, _ref1;
      this.errors = errorArray;
      _ref = this.errors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        errorDescription = (_ref1 = error.stack) != null ? _ref1 : error.toString();
        message = message + '\n' + errorDescription;
      }
      proxyError = Error.call(this, message);
      proxyError.name = "CompoundError";
      errorProperties = Object.getOwnPropertyNames(proxyError);
      for (_j = 0, _len1 = errorProperties.length; _j < _len1; _j++) {
        property = errorProperties[_j];
        if (proxyError.hasOwnProperty(property)) {
          this[property] = proxyError[property];
        }
      }
      return this;
    }

    return CompoundError;

  })(Error);

  PseudoSet = (function() {
    function PseudoSet() {
      var elements;
      elements = [];
      this.add = function(value) {
        if (__indexOf.call(elements, value) < 0) {
          elements.push(value);
        }
        return this;
      };
      this.clear = function() {
        elements = [];
      };
      this["delete"] = function(value) {
        var valueIndex;
        valueIndex = elements.indexOf(value);
        if (valueIndex >= 0) {
          elements.splice(valueIndex, 1);
          return true;
        } else {
          return false;
        }
      };
      this.has = function(value) {
        return __indexOf.call(elements, value) >= 0;
      };
      this.forEach = function(callback) {
        var element, _i, _len;
        for (_i = 0, _len = elements.length; _i < _len; _i++) {
          element = elements[_i];
          callback(element);
        }
      };
    }

    return PseudoSet;

  })();

}).call(this);
